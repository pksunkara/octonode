// Generated by CoffeeScript 1.6.3
(function() {
  var Repo,
    __slice = [].slice;

  Repo = (function() {
    function Repo(name, client) {
      this.name = name;
      this.client = client;
    }

    Repo.prototype.info = function(cb) {
      return this.client.get("/repos/" + this.name, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo info error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.collaborators = function(cbOrUser, cb) {
      if ((cb != null) && typeof cbOrUser !== 'function') {
        return this.hasCollaborator(cbOrUser, cb);
      } else {
        cb = cbOrUser;
        return this.client.get("repos/" + this.name + "/collaborators", function(err, s, b) {
          if (err) {
            return cb(err);
          }
          if (s !== 200) {
            return cb(new Error("Repo collaborators error"));
          } else {
            return cb(null, b);
          }
        });
      }
    };

    Repo.prototype.hasCollaborator = function(user, cb) {
      return this.client.get("repos/" + this.name + "/collaborators/" + user, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 204 && s !== 404) {
          return cb(new Error("Repo hasCollaborator error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.commits = function(cb) {
      return this.client.get("/repos/" + this.name + "/commits", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo commits error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.commit = function(sha, cb) {
      return this.client.get("/repos/" + this.name + "/commits/" + sha, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo commits error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.tags = function(cb) {
      return this.client.get("/repos/" + this.name + "/tags", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo tags error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.languages = function(cb) {
      return this.client.get("/repos/" + this.name + "/languages", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo languages error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.contributors = function(cb) {
      return this.client.get("/repos/" + this.name + "/contributors", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo contributors error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.teams = function(cb) {
      return this.client.get("/repos/" + this.name + "/teams", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo teams error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.branches = function(cb) {
      return this.client.get("/repos/" + this.name + "/branches", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo branches error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.issues = function() {
      var cb, params, _i, _ref;
      params = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      return (_ref = this.client).get.apply(_ref, ["/repos/" + this.name + "/issues"].concat(__slice.call(params), [function(err, s, b, headers) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo issues error"));
        } else {
          return cb(null, b, headers);
        }
      }]));
    };

    Repo.prototype.create_issue_comment = function(number, comment, cb) {
      return this.client.post("/repos/" + this.name + "/issues/" + number + "/comments", comment, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error("Repo create_issue_comment error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.create_issue = function(issue, cb) {
      return this.client.post("/repos/" + this.name + "/issues", issue, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error("Repo create_issue error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.edit_issue = function(number, issue, cb) {
      return this.client.patch("/repos/" + this.name + "/issues/" + number, issue, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo edit_issue error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.readme = function(cbOrRef, cb) {
      if ((cb == null) && cbOrRef) {
        cb = cbOrRef;
        cbOrRef = 'master';
      }
      return this.client.get("/repos/" + this.name + "/readme?ref=" + cbOrRef, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo readme error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.contents = function(path, cbOrRef, cb) {
      if ((cb == null) && cbOrRef) {
        cb = cbOrRef;
        cbOrRef = 'master';
      }
      return this.client.get("/repos/" + this.name + "/contents/" + path + "?ref=" + cbOrRef, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo contents error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.archive = function(format, cbOrRef, cb) {
      if ((cb == null) && cbOrRef) {
        cb = cbOrRef;
        cbOrRef = 'master';
      }
      return this.client.get("/repos/" + this.name + "/" + format + "/" + cbOrRef, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 302) {
          return cb(new Error("Repo archive error"));
        } else {
          return cb(null, h['Location']);
        }
      });
    };

    Repo.prototype.forks = function(cb) {
      return this.client.get("/repos/" + this.name + "/forks", function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo forks error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.blob = function(sha, cb) {
      return this.client.get("/repos/" + this.name + "/git/blobs/" + sha, {
        Accept: 'application/vnd.github.raw'
      }, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo blob error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.tree = function(sha, cbOrRecursive, cb) {
      var url;
      if ((cb == null) && cbOrRecursive) {
        cb = cbOrRecursive;
        cbOrRecursive = false;
      }
      url = "/repos/" + this.name + "/git/trees/" + sha;
      if (cbOrRecursive) {
        url += "?recursive=1";
      }
      return this.client.get(url, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo tree error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.destroy = function() {
      var _this = this;
      return this.client.del("/repos/" + this.name, {}, function(err, s, b) {
        if ((err != null) || s !== 204) {
          return _this.destroy();
        }
      });
    };

    Repo.prototype.pr = function(number) {
      return this.client.pr(this.name, number);
    };

    Repo.prototype.prs = function(cbOrPr, cb) {
      if (typeof cb === 'function' && typeof cbOrPr === 'object') {
        return this.createPr(cbOrPr, cb);
      } else {
        cb = cbOrPr;
        return this.client.get("/repos/" + this.name + "/pulls", function(err, s, b) {
          if (err) {
            return cb(err);
          }
          if (s !== 200) {
            return cb(new Error("Repo prs error"));
          } else {
            return cb(null, b);
          }
        });
      }
    };

    Repo.prototype.createPr = function(pr, cb) {
      return this.client.post("/repos/" + this.name + "/pulls", pr, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error("Repo createPr error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.statuses = function(ref, cb) {
      return this.client.get("/repos/" + this.name + "/statuses/" + ref, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo statuses error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.status = function(sha, obj, cb) {
      return this.client.post("/repos/" + this.name + "/statuses/" + sha, obj, function(err, s, b) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error("Repo status error"));
        } else {
          return cb(null, b);
        }
      });
    };

    Repo.prototype.stargazers = function() {
      var cb, page, params, per_page, _i;
      params = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      page = params[0] || 1;
      per_page = params[1] || 30;
      return this.client.get("/repos/" + this.name + "/stargazers", page, per_page, function(err, s, b, headers) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("Repo stargazers error"));
        } else {
          return cb(null, b, headers);
        }
      });
    };

    return Repo;

  })();

  module.exports = Repo;

}).call(this);
