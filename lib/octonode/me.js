// Generated by CoffeeScript 1.12.7
(function() {
  var Cmd, Me,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Cmd = require('./cmd');

  Me = (function(superClass) {
    extend(Me, superClass);

    function Me(client) {
      this.client = client;
    }

    Me.prototype.profile = function(data) {
      return Object.keys(data).forEach((function(_this) {
        return function(e) {
          return _this[e] = data[e];
        };
      })(this));
    };

    Me.prototype.info = function(cb) {
      return this.client.get('/user', function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User info error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.update = function(info, cb) {
      return this.client.post('/user', info, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User update error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.emails = function(cbOrEmails, cb) {
      if ((cb != null) && typeof cbOrEmails !== 'function') {
        return this.setEmails(cbOrEmails, cb);
      } else if ((cb == null) && typeof cbOrEmails !== 'function') {
        return this.deleteEmails(cbOrEmails);
      } else {
        cb = cbOrEmails;
        return this.client.get('/user/emails', function(err, s, b, h) {
          if (err) {
            return cb(err);
          }
          if (s !== 200) {
            return cb(new Error('User emails error'));
          } else {
            return cb(null, b, h);
          }
        });
      }
    };

    Me.prototype.emailsDetailed = function(cb) {
      return this.client.getOptions('/user/emails', {
        headers: {
          Accept: 'application/vnd.github.v3.full+json'
        }
      }, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User emails error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.setEmails = function(emails, cb) {
      return this.client.post('/user/emails', emails, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error('User setEmails error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.deleteEmails = function(emails, cb) {
      return this.client.del('/user/emails', emails, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User deleteEmails error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.followers = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ['/user/followers'].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User followers error'));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.following = function(cbOrUser, cb) {
      if ((cb != null) && typeof cbOrUser !== 'function') {
        return this.checkFollowing(cbOrUser, cb);
      } else {
        cb = cbOrUser;
        return this.client.get('/user/following', function(err, s, b, h) {
          if (err) {
            return cb(err);
          }
          if (s !== 200) {
            return cb(new Error('User following error'));
          } else {
            return cb(null, b, h);
          }
        });
      }
    };

    Me.prototype.checkFollowing = function(user, cb) {
      return this.client.get("/user/following/" + user, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        return cb(null, s === 204, h);
      });
    };

    Me.prototype.follow = function(user, cb) {
      return this.client.put("/user/following/" + user, {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User follow error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.unfollow = function(user, cb) {
      return this.client.del("/user/following/" + user, {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User unfollow error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.starred = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ['/user/starred'].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User starred error'));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.checkStarred = function(repo, cb) {
      return this.client.get("/user/starred/" + repo, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        return cb(null, s === 204, h);
      });
    };

    Me.prototype.star = function(repo, cb) {
      return this.client.put("/user/starred/" + repo, {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User star error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.unstar = function(repo, cb) {
      return this.client.del("/user/starred/" + repo, {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User unstar error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.watched = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ['/user/subscriptions'].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User subscription error'));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.keys = function(cbOrIdOrKey, cbOrKey, cb) {
      if ((cb == null) && typeof cbOrIdOrKey === 'number' && typeof cbOrKey === 'function') {
        return this.getKey(cbOrIdOrKey, cbOrKey);
      } else if ((cbOrKey == null) && (cb == null) && typeof cbOrIdOrKey === 'number') {
        return this.deleteKey(cbOrIdOrKey);
      } else if ((cb == null) && typeof cbOrKey === 'function' && typeof cbOrIdOrKey === 'object') {
        return this.createKey(cbOrIdOrKey, cbOrKey);
      } else if (typeof cb === 'function' && typeof cbOrIdOrKey === 'number' && typeof cbOrKey('object')) {
        return this.updateKey(cbOrIdOrKey, cbOrKey, cb);
      } else {
        cb = cbOrIdOrKey;
        return this.client.get('/user/keys', function(err, s, b, h) {
          if (err) {
            return cb(err);
          }
          if (s !== 200) {
            return cb(new Error('User keys error'));
          } else {
            return cb(null, b, h);
          }
        });
      }
    };

    Me.prototype.getKey = function(id, cb) {
      return this.client.get("/user/keys/" + id, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User getKey error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.createKey = function(key, cb) {
      return this.client.post('/user/keys', key, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error('User createKey error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.updateKey = function(id, key, cb) {
      return this.client.post("/user/keys/" + id, key, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User updateKey error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.deleteKey = function(id, cb) {
      return this.client.del("/user/keys/" + id, {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error("User deleteKey error"));
        } else {
          return cb(null);
        }
      });
    };

    Me.prototype.org = function(name) {
      return this.client.org(name);
    };

    Me.prototype.orgs = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ["/user/orgs"].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User orgs error'));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.updateMembership = function(org, state, cb) {
      var info;
      info = {
        state: state
      };
      return this.client.patch("/user/memberships/orgs/" + org, info, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User org update error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.repo = function(nameOrRepo, cb) {
      if (typeof cb === 'function' && typeof nameOrRepo === 'object') {
        return this.createRepo(nameOrRepo, cb);
      } else {
        return this.client.repo(nameOrRepo);
      }
    };

    Me.prototype.repos = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ["/user/repos"].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User repos error'));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.createRepo = function(repo, cb) {
      return this.client.post("/user/repos", repo, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 201) {
          return cb(new Error('User createRepo error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.fork = function(repo, cb) {
      return this.client.post("/repos/" + repo + "/forks", {}, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 202) {
          return cb(new Error('User fork error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.pr = function(repo, number) {
      return this.client.pr(repo, number);
    };

    Me.prototype.notifications = function(options, cb) {
      if (options == null) {
        options = {};
      }
      return this.client.get("/notifications", options, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User notification error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.checkWatching = function(repo, cb) {
      return this.client.get("/repos/" + repo + "/subscription", function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s === 200) {
          return cb(null, b, h);
        } else {
          return cb(null, false, h);
        }
      });
    };

    Me.prototype.subscribe = function(repo, cb) {
      var options;
      options = {
        subscribed: true,
        ignored: false
      };
      return this.client.put("/repos/" + repo + "/subscription", options, function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error('User subscribe error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.unsubscribe = function(repo, cb) {
      return this.client.del("/repos/" + repo + "/subscription", function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 204) {
          return cb(new Error('User unsubscribe error'));
        } else {
          return cb(null, b, h);
        }
      });
    };

    Me.prototype.issues = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ["/user/issues"].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("User issues error"));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    Me.prototype.teams = function() {
      var cb, i, params, ref;
      params = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      return (ref = this.client).get.apply(ref, ["/user/teams"].concat(slice.call(params), [function(err, s, b, h) {
        if (err) {
          return cb(err);
        }
        if (s !== 200) {
          return cb(new Error("User teams error"));
        } else {
          return cb(null, b, h);
        }
      }]));
    };

    return Me;

  })(Cmd);

  module.exports = Me;

}).call(this);
